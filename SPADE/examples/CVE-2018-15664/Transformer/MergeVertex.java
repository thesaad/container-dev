package spade.transformer;

import java.io.File;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Collection;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.apache.commons.io.FileUtils;

import spade.core.AbstractEdge;
import spade.core.AbstractTransformer;
import spade.core.AbstractVertex;
import spade.core.Graph;
import spade.core.Settings;
import spade.utility.HelperFunctions;
import spade.reporter.audit.OPMConstants;

public class MergeVertex extends AbstractTransformer{

    private final static Logger logger = Logger.getLogger(MergeVertex.class.getName());
    private String[] mergeBaseKeys = null;

    //arguments will be the attribute based on which a vertex will be marked as equal to other, it can be a single key or comma separated keys
    public boolean initialize(String arguments){
        if(arguments == null || arguments.length() == 0){
            logger.log(Level.SEVERE, "No key is provided.");
            return false;
        }else{
            mergeBaseKeys = arguments.split(",");
        }

        return true;
    }

    @Override
    public LinkedHashSet<ArgumentName> getArgumentNames(){
        return new LinkedHashSet<ArgumentName>();
    }

    @Override
    public Graph transform(Graph graph, ExecutionContext context){
        //find frequent vertices
        
        
        
        Map<String, Integer> vertexFrequencies = new HashMap<String, Integer>();
        Map<String, AbstractVertex> frequentVertices = new HashMap<String, AbstractVertex>();
        Set<String> frequentHashes = new HashSet<String>();

        for(AbstractVertex vertex : graph.vertexSet()){
            String hash = vertexHashForKeys(mergeBaseKeys, vertex);
	    if(hash == null || hash.length() == 0) { continue;}
            if (vertexFrequencies.get(hash) == null || vertexFrequencies.get(hash)  == 0) {

                vertexFrequencies.put(hash, 1);
                frequentVertices.put(hash, vertex);
                
            } else {

                vertexFrequencies.put(hash, vertexFrequencies.get(hash) + 1);
                AbstractVertex v = frequentVertices.get(hash);
                
                for (String annoationKey : vertex.getAnnotationKeys()) {
                    String newAnnotation = vertex.getAnnotation(annoationKey);
                    String oldAnnotation = v.getAnnotation(annoationKey);//new vertex

                    if (newAnnotation != null && oldAnnotation != null && !oldAnnotation.contains(newAnnotation)){

                        v.removeAnnotation(annoationKey);
                        v.addAnnotation(annoationKey, oldAnnotation + "," + vertex.getAnnotation(annoationKey));
                    } else if (oldAnnotation != null && newAnnotation == null){
                        v.addAnnotation(annoationKey, oldAnnotation);
                    }
                }
                frequentVertices.put(hash, v);//merged vertex
                frequentHashes.add(hash); //record frequent vertex
                
            }
        }


        Graph resultGraph = new Graph();

        for(String freqVertexHash : frequentHashes) {
            
            for(AbstractEdge edge : graph.edgeSet()) {
                AbstractEdge newEdge = createNewWithoutAnnotations(edge, OPMConstants.EDGE_SIZE);
                
                if(edge.getChildVertex() != null) {
                    String hash = vertexHashForKeys(mergeBaseKeys, edge.getChildVertex());
                    if(hash != null && hash.equals(freqVertexHash)) {
                        newEdge.setChildVertex(frequentVertices.get(freqVertexHash));
                    }
                    
                }
                if(edge.getParentVertex() != null) {
                    String hash = vertexHashForKeys(mergeBaseKeys, edge.getParentVertex());
                    if(hash != null && hash.equals(freqVertexHash)) {
                        newEdge.setParentVertex(frequentVertices.get(freqVertexHash));
                    }
                }
                resultGraph.putVertex(newEdge.getChildVertex());
                resultGraph.putVertex(newEdge.getParentVertex());
                resultGraph.putEdge(newEdge);
                
            }

        }

        return resultGraph;
    }
    private String vertexHashForKeys(String[] keys, AbstractVertex vertex) {

	String hash = new String();
        for (String key : keys) {
	    String annotation = vertex.getAnnotation(key);
	    if(annotation != null && annotation.length() > 0) 
            	hash += key + annotation + ",";
        }

        return hash;
    }
}
